#!/bin/sh

# MacOS has a permission problem with volume mounts
# Regardless of what user owns the real folder on the host, it is always mounted root:root
# As such, our container needs to run root:root in order for paths to be writable.
IS_MACOS_MESSED_UP=1

# The name of the script running. This should be a symlink from a named script, like adguardhome
# to this script which can be generically named
_name="$(basename "$0")"

# The root of docker configuration on the host machine
_root="/usr/local/etc/docker"
_app="${_root}/${_name}"

# Run containers unprivileged but also not as our own user
# Since a container runs as root by default that's bad, though root in a container
# On MacOS we have a permission problem with files created in containers ignoring UID, so we instead ensure
# docker runs as our current local user
if [ "$(uname)" = "Darwin" ] && [ "${IS_MACOS_MESSED_UP}" -ne 0 ]; then
  printf -- 'MacOS is buggy. Do not attempt user permission seperation.\n'
  _user="$(id -un)"
  _group="$(id -gn)"
else
  # Run every container as a dynamically created docker-* user
  # in the dockerusers group.
  #
  # The real user should be a member of the dockerusers group so they can still interact with files
  _user="docker-${_name}"
  _group="dockerusers"
fi

##
# Attempt to create an empty container
#
# $1
attempt_create_container()
{
  create_container="$1"

  # Check we have container
  if [ -z "${create_container}" ]; then
    printf -- 'Could not attempt container create, no name defined.\n'

    unset create_container
    return 1
  fi

  # Make the root directory
  mkdir -p "${_app}" || {
    printf -- 'Unable to create docker directory: %s\n' "${_app}"

    unset create_container
    return 1
  }

  # Own the directory as the docker user
  chown "${_user}:${_group}" "${_app}" || {
    printf -- 'Failed to own the host directory %s\n' "${_app}"

    unset create_container
    return 1
  }

  # Mark the directory accessible to owner and group only
  chmod 750 "${_app}" || {
    printf -- 'Failed to chmod the host directory %s\n' "${_app}"

    unset create_container
    return 1
  }

  # Create empty config
  #
  printf -- '%s\n' "$(cat << EOF
# Comments look like this
#
# This file is directly source by POSIX sh script. Make sure you quote strings and
# do not execute any unexpected code. Not Secure.
#
# All lines must be double-quoted (with escape rules like a shell script) or stuff wont work.
#
# [REQUIRED]
# CONTAINER_TARGET
#
# [OPTIONAL]
# CONTAINER_DIRS
# CONTAINER_PORTS
# CONTAINER_CAPS
# CONTAINER_USER
# CONTAINER_OPTIONS
# CONTAINER_ARGS

# The name of the container to run
# CONTAINER_TARGET="adguard/adguardhome"
CONTAINER_TARGET=""

# Directories: Format like -v/--volume
# CONTAINER_DIRS="directory:/root/directory"
CONTAINER_DIRS=""

# Ports: Format like -p/--port
# CONTAINER_PORTS="80:80/tcp 443:443/tcp"
CONTAINER_PORTS=""

# Capabilities: Format like --cap-add (these are only added, everything is DROPPED by default)
# CONTAINER_CAPS="NET_BIND_SERVICE NET_ADMIN"
CONTAINER_CAPS=""

# User: Override the --user option passed to the container.
# Pass UID:GID instead of names for maximum compatibility.
# CONTAINER_USER="1000:1000"
CONTAINER_USER=""

# Options: Any options passed to the container raw
# CONTAINER_OPTIONS="-i -t --read-only"
CONTAINER_OPTIONS=""

# Arguments: Passed directly to the command ran inside the container (will be used only if no arguments are passed on command line)
# CONTAINER_ARGS="--verbose help"
CONTAINER_ARGS=""
EOF
)" > "${create_container}"

  printf -- 'Created empty container environment at %s\n' "${create_container}"

  # Own the configuration as the root user
  chown 0:0 "${create_container}" || {
    printf -- 'Failed to own the host configuration file %s\n' "${_app}"

    unset create_container
    return 1
  }

  # Mark the configuration accessible to owner and group only
  chmod 600 "${create_container}" || {
    printf -- 'Failed to chmod the host configuration file %s\n' "${_app}"

    unset create_container
    return 1
  }

  unset create_container
  return 0
}

##
# Source container environment
# 
# $1 file
source_container()
{
  container_env="$1"

  if [ ! -r "${container_env}" ]; then
    # We failed, but try to create the directory
    attempt_create_container "${container_env}" || {
      printf -- 'Failed to create attempted container: %s\n' "${container_env}"
      unset container_env
      return 1
    }

    unset container_env
    return 1
  fi

  # shellcheck disable=SC1090
  . "${container_env}"

  # Export
  export CONTAINER_TARGET
  export CONTAINER_DIRS
  export CONTAINER_PORTS
  export CONTAINER_CAPS
  export CONTAINER_OPTIONS
  export CONTAINER_ARGS

  unset container_env
  return 0
}

##
# Make directories
#
prepare_dirs()
{
  for d in ${CONTAINER_DIRS}; do
    # This is a volume format, grab just the host directory name
    # Split the string by ':' => directory:/container/directory -> directory /container/directory
    # Grab only the first section => direction /container/directory -> directory
    # Prepend the _app container and run mkdir
    path_d="${_app}/$(printf -- '%s' "${d}" | tr ':' ' ' | awk '{ print $1 }')"
    printf -- 'Create host directory: %s\n' "${path_d}"
    mkdir -p "${path_d}" || {
      printf -- 'Failed to create host directory %s\n' "${path_d}"

      unset d
      unset path_d
      return 1
    }

    # Own the directory as the docker user
    chown "${_user}:${_group}" "${path_d}" || {
      printf -- 'Failed to own the host directory %s\n' "${path_d}"

      unset d
      unset path_d
      return 1
    }

    # Mark the directory accessible to owner and group only
    chmod 750 "${path_d}" || {
      printf -- 'Failed to chmod the host directory %s\n' "${path_d}"

      unset d
      unset path_d
      return 1
    }

    unset d
    unset path_d
  done

  return 0
}

##
# Enable bridge networking on MacOS
__mac_enable_bridge_network()
{
  printf -- 'MacOS enables bridge networking through VM implementation\n'
  return 0
}

##
# Enable bridge networking on Linux
__linux_enable_bridge_network()
{
  # Enable IP forwarding for container bridge networking
  printf -- 'Enable IPv4 forwarding for bridge networking\n'
  sysctl -q -w net.ipv4.ip_forward=1 || {
    printf -- 'Failed to enable IPv4 forwarding\n'
    return 1
  }

  return 0
}

##
# Setup container networking
#
enable_bridge_network()
{
  # If we are running on MacOS, this sysctl won't work
  if [ "$(uname)" = "Darwin" ]; then
    __mac_enable_bridge_network || return 1
  else
    __linux_enable_bridge_network || return 1
  fi

  return 0
}

##
# Check the container configuration is valid
check_container()
{
  if [ -z "${CONTAINER_TARGET}" ]; then
    printf -- 'Missing CONTAINER_TARGET for %s. Is your container environment valid?\n' "${_name}"
    return 1
  fi

  return 0
}

##
# Compile together all the container options
compile_container_options()
{
  my_container_options=""

  # Volume mounts
  for d in ${CONTAINER_DIRS}; do
    my_container_options="${my_container_options} -v ${_app}/${d}"
  done

  # Expose ports
  for p in ${CONTAINER_PORTS}; do
    my_container_options="${my_container_options} -p ${p}"
  done

  # Add capabilities
  for c in ${CONTAINER_CAPS}; do
    my_container_options="${my_container_options} --cap-add ${c}"
  done

  # Generic raw options
  for o in ${CONTAINER_OPTIONS}; do
    my_container_options="${my_container_options} ${o}"
  done

  # Echo out
  printf -- '%s' "${my_container_options}"

  unset my_container_options

  # Unset environment
  unset CONTAINER_DIRS
  unset CONTAINER_PORTS
  unset CONTAINER_CAPS
  unset CONTAINER_OPTIONS

  # Don't unset CONTAINER_ARGS since we need them
  # unset CONTAINER_ARGS
  #
  # Don't unset CONTAINER_USER since we need them
  # unset CONTAINER_USER
  
  return 0
}

##
# Compile container arguments
#
# $@ all arguments
compile_container_args()
{
  my_container_args=""

  # If we have args passed, take them, otherwise use defaults
  if [ "$#" -le 0 ]; then
    my_container_args="${CONTAINER_ARGS}"
  else
    # Use $* instead of $@ so we don't expand the array - we want it as a string we will expand later
    my_container_args="$*"
  fi

  # Echo out
  printf -- '%s' "${my_container_args}"

  unset my_container_args

  # Unset environment
  unset CONTAINER_ARGS

  return 0
}

##
# Creates a docker user and group for safer container access on Linux
__linux_create_docker_usergroup()
{
  # Check that the group does not already exist
  if ! getent group "${_group}" > /dev/null; then
    printf -- 'Creating docker container group: %s\n' "${_group}"
    # Create a group for docker users
    # Assign it to the _group as primary
    groupadd "${_group}" || {
      printf -- 'Could not make docker group: %s\n' "${_group}"
      return 1
    }
  fi

  # Check that the user does not already exist
  if ! getent passwd "${_user}" > /dev/null; then
    printf -- 'Creating docker container user: %s\n' "${_user}"
    # Create a user with no home, and no user group.
    # Assign it to the _group as primary
    useradd --no-create-home --no-user-group -g "${_group}" "${_user}" || {
      printf -- 'Could not make docker user: %s\n' "${_user}"
      return 1
    }
  fi

  # Add user to group
  gpasswd -a "${_user}" "${_group}" || {
    printf -- 'Failed to add docker user to group %s -> %s\n' "${_user}" "${_group}"
    return 1
  }

  return 0
}

##
# Creates a docker user and group for safer container access on MacOS
#
# May not do anything since MacOS is buggy with user permissions
__mac_create_docker_usergroup()
{
  if [ "${IS_MACOS_MESSED_UP}" -ne 0 ]; then
    # MacOS volume mounting UID permission is messed up, don't do it
    printf -- 'MacOS volume mounts are messed up, do not dscl\n'
  else
    # Check that the group does not already exist
    if ! dscl . list /groups | grep "${_group}" > /dev/null; then
      highest_gid="$(dscl . list /groups PrimaryGroupID | awk '{print $2}' | sort -n | tail -n 1)"
      new_gid="$(( highest_gid + 1 ))"

      # Create the group
      dscl . create /Groups/"${_group}" || {
        printf -- 'Failed to create /Groups/%s\n' "${_group}"

        unset highest_gid
        unset new_gid
        return 1
      }

      # Assign group ID
      dscl . create /Groups/"${_group}" gid "${new_gid}" || {
        printf -- 'Failed to assign /Groups/%s GID: %s\n' "${_group}" "${new_gid}"

        unset highest_gid
        unset new_gid
        return 1
      }

      # Assign Group name
      dscl . create /Groups/"${_group}" RealName "Docker Users" || {
        printf -- 'Failed to assign /Groups/%s RealName\n' "${_group}"

        unset highest_gid
        unset new_gid
        return 1
      }

      # Assign Group passwd
      dscl . create /Groups/"${_group}" passwd "*" || {
        printf -- 'Failed to assign /Groups/%s passwd\n' "${_group}"

        unset highest_gid
        unset new_gid
        return 1
      }

      unset highest_gid
      unset new_gid
    fi

    # Check that the user does not exist
    if ! dscl . list /users | grep "${_user}" > /dev/null; then
      highest_uid="$(dscl . list /users UniqueID | awk '{print $2}' | sort -n | tail -n 1)"
      new_uid="$(( highest_uid + 1 ))"

      # Create user
      dscl . -create /Users/"${_user}" || {
        printf -- 'Failed to create new user %s\n' "${_user}"

        unset highest_uid
        unset new_uid
        return 1
      }

      # Assign UID
      dscl . -create /Users/"${_user}" UniqueID "${new_uid}"  || {
        printf -- 'Failed to assign  user UID %s %s\n' "${_user}" "${new_uid}"

        unset highest_uid
        unset new_uid
        return 1
      }

      existing_group_id="$(dscl . list /groups PrimaryGroupID | grep "${_group}" | awk '{print $2}')"

      dscl . -create /Users/"${_user}" UserShell /bin/nologin
      dscl . -create /Users/"${_user}" RealName "Docker ${_name}"
      dscl . -create /Users/"${_user}" PrimaryGroupID "${existing_group_id}"

      unset highest_uid
      unset new_uid
    fi

    # Add user to group
    dscl . append /Groups/"${_group}" GroupMembership "${_user}" || {
      printf -- 'Failed to add user to group %s -> %s\n' "${_user}" "${_group}"
      return 1
    }
  fi

  return 0
}

##
# Creates a docker user and group for safer container access
create_docker_usergroup()
{
  if [ "$(uname)" = "Darwin" ]; then
    __mac_create_docker_usergroup || return 1
  else
    __linux_create_docker_usergroup || return 1
  fi

  return 0
}

##
# Decide the --user that the container will run as
resolve_container_user()
{
  my_container_user=""

  # For some reason, even volume mounts as root into docker instead of as the docker user.
  # Beacuse of this, just run docker assuming our local user on MacOS only
  if [ -n "${CONTAINER_USER}" ]; then
    # Manual override, may not work on MacOS
    my_container_user="--user ${CONTAINER_USER}"
  elif [ "$(uname)" = "Darwin" ] && [ "${IS_MACOS_MESSED_UP}" -ne 0 ]; then
    # Blank it out as if we had never passed an option - will run the user as default container user or as root.
    # On MacOS, even though the container says root, files are created with the correct user and permissions.
    my_container_user=""
  else
    # You must run --user with UID:GID instead of names or docker won't resolve names created on the fly.
    #
    # Failing to specify a user runs the container user as root, and files created in the container
    # are marked as created by root user 0
    my_container_user="--user $(id -u "${_user}"):$(id -g "${_user}")"
  fi

  # Echo out
  printf -- '%s' "${my_container_user}"

  unset my_container_user

  # Unset environment
  unset CONTAINER_USER

  return 0
}

main()
{
  # We don't need to check for root as the command will fail
  # if a user lacks privs either during directory prep
  # or when running docker.
  #
  # We don't need to be root per se, just have perm and docker access.

  # Set the umask for user, group, but no other
  umask 0027 || {
    printf -- 'Failed to set restrictive umask 0027\n'
    return 1
  }

  # Create docker user and group
  create_docker_usergroup || {
    printf -- 'Failed to create docker usergroup %s %s\n' "${_user}" "${_group}"
    return 1
  }

  # Source the container environment
  source_container "${_app}/container" || {
    printf -- 'Could not source container environment file: %s\n' "${_app}/container"
    return 1
  }

  # Validate the container environment
  check_container || {
    printf -- 'Invalid docker environment %s\n' "${_name}"
    return 1
  }

  # Set IP forwarding for bridge networking
  enable_bridge_network || {
    printf -- 'Could not enable bridge network for container %s.\n' "${_name}"
    return 1
  }

  # Prepare mounts
  if [ -n "${CONTAINER_DIRS}" ]; then
    prepare_dirs || {
      printf -- 'Could not setup docker directories %s\n' "${CONTAINER_DIRS}"
      return 1
    }
  fi

  # Compile all options into one
  options="$(compile_container_options)"
  docker_user="$(resolve_container_user)"

  printf -- 'Running container %s as user: %s\n' "${CONTAINER_TARGET}" "${docker_user}"

  if [ "$1" = "systemd" ]; then
    # Eat argument
    shift

    # Then grab args
    args="$(compile_container_args "$@")"

    # Don't quote expansion - we want the raw strings
    # shellcheck disable=SC2086
    exec docker run \
      --name "${_name}" \
      --init \
      --security-opt no-new-privileges \
      --cap-drop ALL \
      --rm \
      ${docker_user} \
      ${options} "${CONTAINER_TARGET}" ${args}
  else
    # Then grab args
    args="$(compile_container_args "$@")"

    # Don't quote expansion - we want the raw strings
    # shellcheck disable=SC2086
    exec docker run \
      --name "${_name}" \
      --init \
      --security-opt no-new-privileges \
      --cap-drop ALL \
      --restart unless-stopped -d \
      ${docker_user} \
      ${options} "${CONTAINER_TARGET}" ${args}
   fi
}

main "$@" || exit 1
exit 0
