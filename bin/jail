#!/bin/sh

# A simple jail which isolated user files from the greater HOME directory
#
# See _usage for details

readonly VERSION="0.0.4"
readonly MY_PID="$$"

# Can be overridden by the environment
readonly JAIL_DIR="${JAIL_DIR:-${HOME}/.local/etc/jails}"

# IFS of only newline
readonly __NEWLINE_IFS="
"

_clean_path() {
  _current_path="${PATH}"

  #
  # Reverse the path so we add back the paths in FIFO order
  _split_path="$(printf -- '%s' "${_current_path}" | tr ':' '\n' | tac)"
  _cleaned_path=""
  for _path in ${_split_path}; do
    # Remove any ${HOME} entries from the path
    case "${_path}" in
    "${HOME}"/*)
      unset _path
      continue
      ;;
    *)
      if [ -z "${_cleaned_path}" ]; then
        _cleaned_path="${_path}"
      else
        _cleaned_path="${_path}:${_cleaned_path}"
      fi
      unset _path
      ;;
    esac
    unset _path
  done
  unset _path

  PATH="${_cleaned_path}"
  export PATH
  return 0
}

_create_home() {
  _home="$1"

  # Create the jail root
  mkdir -p "${_home}/home" "${_home}/var/tmp" || {
    printf -- 'Failed to create jail dir: %s\n' "${_home}"

    unset _home
    return 1
  }

  unset _home
  return 0
}

# Bind a symlink into the jail, and resolve it's real path
_bind_symlink() {
  _bind_symlink_bind="$1"
  _bind_symlink_path="$2"

  if [ -L "${_bind_symlink_path}" ]; then
    _resolv_link="$(readlink "${_bind_symlink_path}")"
    _resolv_real_link="$(readlink -f "${_bind_symlink_path}")"

    printf -- '--%s
%s
%s
' "${_bind_symlink_bind}" "${_bind_symlink_path}" "${_resolv_link}"

    if [ "${_resolv_link}" != "${_resolv_real_link}" ]; then
      printf -- '--%s
%s
%s
' "${_bind_symlink_bind}" "${_resolv_link}" "${_resolv_real_link}"
    fi

    unset _resolv_link
    unset _resolv_real_link
  fi

  unset _bind_symlink_bind
  unset _bind_symlink_path
  return 0
}

_usage() {
  printf -- '%s\n' "$(
    cat <<EOF
jail [${VERSION}]

Runs a command in a jail.

What is a jail?
---------------

A jail separates the program's \${HOME} from the real user's \${HOME}
directory. The main goal of the jail is user \${HOME} separation.
The fact that the jail also isolates by default sensitive system
directories and restricts unsafe X11/Wayland access is a bonus feature,
which can be changed or removed at any time in favor of cleaner
\${HOME} isolation.

Jails are located in: ${JAIL_DIR} by default
---------------

\$ jail [options] -- <command> [bwrap-options] -- [command-options]

You must pass "--" before the command, EVEN IF you do not use any options.

Any arguments passed after the <command> will be interpreted as options for bwrap.
Any arguments passed after the command and "--" will be passed to the command

[Options]
--name <name>    Name the jail (otherwise uses the command name)
--shell          Open a shell in the jail instead of executing the command
--x11            Bind paths for running with X11/XWayland
--wayland        Bind paths for running with Wayland
-h | --help      Prints this help

EOF
  )"
}

##
# Bind to the same path in the jail
#
# $1 bind type bind|ro-bind|dev-bind
# $2.. path
_bind_in_jail() {
  _bind_type="$1"
  shift

  # No path provided, stop
  if [ -z "$1" ]; then
    return 1
  fi

  # Rest are paths
  for _path in "$@"; do
    if [ -e "${_path}" ]; then
      printf -- '--%s
%s
%s
' "${_bind_type}" "${_path}" "${_path}"
    fi
    unset _path
  done
  unset _path

  unset _bind_type
  return 0
}

##
# Block the path in the jail
#
# $1.. path
_block_in_jail() {
  # No path provided, stop
  if [ -z "$1" ]; then
    return 1
  fi

  # Rest are paths
  for _path in "$@"; do
    if [ -e "${_path}" ]; then
      if [ -d "${_path}" ]; then
        # Block directory via tmpfs
        printf -- '--tmpfs
%s
' "${_path}"
      else
        # Block file by symlinking to /dev/null
        printf -- '--symlink
/dev/null
%s
' "${_path}"
      fi
    fi
    unset _path
  done
  unset _path

  return 0
}

_wrap() {
  # Log outputs, fail on anything
  set -xeu

  exec bwrap "$@"
}

_run_jail() {
  _j_cmd="$1"
  _j_jail="$2"
  _j_name="$3"

  _j_open_shell="$4"
  _j_x11="$5"
  _j_wayland="$6"

  # The rest of the arguments are commands
  shift
  shift
  shift
  shift
  shift
  shift

  # Use a new session
  _j_session="--new-session"

  # If we are opening a shell, override the command
  # and keep current session
  if [ "${_j_open_shell}" -eq 1 ]; then
    _j_cmd="${SHELL:-/bin/bash}"
    _j_session=""
  fi
  unset _j_open_shell
  readonly _j_session
  readonly _j_cmd

  _clean_path || return 1

  _bwrap_args=""
  for _a in "$@"; do
    if [ "${_a}" = "--" ]; then
      shift
      unset _a

      break
    fi

    if [ -z "${_bwrap_args}" ]; then
      _bwrap_args="$1"
    else
      _bwrap_args="${_bwrap_args}
$1"
    fi
    shift
    unset _a
  done
  unset _a
  readonly _bwrap_args

  _cmd_args=""
  for _a in "$@"; do
    if [ "${_a}" = "--" ]; then
      shift
      unset _a

      break
    fi

    if [ -z "${_cmd_args}" ]; then
      _cmd_args="$1"
    else
      _cmd_args="${_cmd_args}
$1"
    fi

    shift
    unset _a
  done
  unset _a
  readonly _cmd_args

  # Isolate user $HOME
  _j_home_binds="$(_block_in_jail "/home")
--bind
${_j_jail}/home
${HOME}"

  # Add in extra nice-to-have directories
  # For things like icons, theme, and fonts
  #
  # Explicitly restrict access to SSH
  # Explicitly restrict access to GNUPG
  # Explicitly restrict access to some pre-defined password file locations
  _j_home_binds="${_j_home_binds}
$(_bind_in_jail "ro-bind" "${HOME}/.themes" "${HOME}/.icons" "${HOME}/.fonts")
$(_bind_in_jail "ro-bind" "${XDG_CONFIG_HOME:-${HOME}/.config}"/fontconfig)
$(_bind_in_jail "ro-bind" "${XDG_CONFIG_HOME:-${HOME}/.config}"/gtk-*)
$(_bind_in_jail "ro-bind" "${XDG_CACHE_HOME:-${HOME}/.cache}"/fontconfig)
$(_bind_in_jail "ro-bind" "${XDG_CACHE_HOME:-${HOME}/.cache}"/gtk-*)
$(_bind_in_jail "ro-bind" "${XDG_CACHE_HOME:-${HOME}/.cache}"/icon-cache.kcache)
$(_bind_in_jail "bind" "${XDG_CONFIG_HOME:-${HOME}/.config}"/dconf)
$(_block_in_jail "${XDG_CONFIG_HOME:-${HOME}/.config}/gnupg" "${GNUPGHOME}")
$(_block_in_jail "${XDG_CONFIG_HOME:-${HOME}/.config}/.keepass" "${HOME}/.keepass")
$(_block_in_jail "${XDG_CONFIG_HOME:-${HOME}/.config}/keepass" "${HOME}/keepass")
$(_block_in_jail "${XDG_CONFIG_HOME:-${HOME}/.config}/.passwords" "${HOME}/.passwords")
$(_block_in_jail "${XDG_CONFIG_HOME:-${HOME}/.config}/passwords" "${HOME}/passwords")"

  _j_sys_binds=""
  _j_env=""

  # If resolv conf is a symlink, bind the real file too
  _j_sys_binds="${_j_sys_binds}
$(_bind_symlink "ro-bind" "/etc/resolv.conf")"

  # If X11 usage is enabled, bind X11 files
  if [ -n "${_j_x11}" ] && [ "${_j_x11}" -eq 1 ]; then
    # Mount back the user runtime dir and add extra binds for .X11 in /tmp
    _j_sys_binds="${_j_sys_binds}
$(_bind_in_jail "bind" /tmp/.X*-lock /tmp/.*-unix)"

    # Add back XAUTHORITY
    if [ -n "${XAUTHORITY}" ]; then
      _j_env="${_j_env}
--setenv
XAUTHORITY
${XAUTHORITY}"
    fi

    # Add back DISPLAY
    if [ -n "${DISPLAY}" ]; then
      _j_env="${_j_env}
--setenv
DISPLAY
${DISPLAY}"
    fi
  else
    _j_sys_binds="${_j_sys_binds}
$(_block_in_jail "/etc/X11" "/usr/share/X11" "/usr/lib/X11")"

    # Remove XAUTHORITY
    _j_env="${_j_env}
--unsetenv
XAUTHORITY"

    # Remove DISPLAY
    _j_env="${_j_env}
--unsetenv
DISPLAY"
  fi

  # If Wayland is enabled, bind Wayland
  if [ -n "${_j_wayland}" ] && [ "${_j_wayland}" -eq 1 ]; then
    # Add back WAYLAND_DISPLAY
    if [ -n "${WAYLAND_DISPLAY}" ]; then
      _j_env="${_j_env}
--setenv
WAYLAND_DISPLAY
${WAYLAND_DISPLAY}"
    fi
  else
    # Remove WAYLAND_DISPLAY
    _j_env="${_j_env}
--unsetenv
WAYLAND_DISPLAY"
  fi

  readonly _j_home_binds
  readonly _j_sys_binds
  readonly _j_env

  _runtimedir="${XDG_RUNTIME_DIR:-/run/user/$(id -u)}"
  readonly _runtimedir

  # Weird newline delimited format :)
  #
  # unshare namespaces [don't unshare net (internet) and don't unshare IPC (x11)]
  # dev-bind root so everything works the same as it would outside
  # tmpfs bind /tmp for security
  # mount new proc on /proc
  # Mount a new home
  # Mark the process
  #
  # Unset the SESSION_MANAGER var
  # https://stackoverflow.com/questions/59057653/qt-session-management-error-none-of-the-authentication-protocols-specified-are
  #
  # Overwrite /tmp /run /var and /proc
  # /sys is overwritten but the char and pci devices are mounted back in for 3d accel
  # Mount dbus system socket
  # Mount cups socket
  #
  _j_all="${_j_session}
--die-with-parent
--cap-drop
ALL
--unshare-user
--unshare-ipc
--unshare-pid
--unshare-uts
--unshare-cgroup
--setenv
JAIL_PID
${MY_PID}
--setenv
JAIL_NAME
${_j_name}
--setenv
JAIL_PROGRAM
${_j_cmd}
--unsetenv
SESSION_MANAGER
--unsetenv
SSH_AUTH_SOCK
--unsetenv
MANAGERPID
--unsetenv
SYSTEMD_EXEC_PID
--unsetenv
JOURNAL_STREAM
--unsetenv
INVOCATION_ID
${_j_env}
$(_bind_in_jail "dev-bind" "/")
--proc
/proc
--mqueue
/dev/mqueue
$(_block_in_jail "/boot" "/run" "/tmp" "/var" "/sys" "/opt")
$(_block_in_jail "/usr/lib/modules" "/usr/lib/modprobe.d" "/usr/lib/modules-load.d")
$(_block_in_jail "/usr/share/iptables" "/usr/share/nftables" "/usr/share/firewalld")
$(_block_in_jail "/usr/share/polkit-1")
$(_block_in_jail "/usr/share/flatpak")
$(_block_in_jail "/usr/lib/udev" "/usr/lib/sudo" "/usr/lib/sysctl.d")
$(_block_in_jail "/usr/lib/sunshine")
$(_block_in_jail "/usr/lib/systemd")
$(_block_in_jail "/etc/kernel" "/etc/keyutils")
$(_block_in_jail "/etc/modprobe.d" "/etc/modules-load.d")
$(_block_in_jail "/etc/credstore" "/etc/credstore.encrypted")
$(_block_in_jail "/etc/iptables" "/etc/firewalld" "/etc/firewall")
$(_block_in_jail "/etc/polkit-1" "/etc/udev")
$(_block_in_jail "/etc/sudoers.d" "/etc/sysctl.d")
$(_block_in_jail "/etc/systemd")
$(_block_in_jail "/etc/flatpak")
$(_block_in_jail "/etc/ssh")
$(_block_in_jail "/etc/cryptsetup-keys.d/")
$(_bind_in_jail "dev-bind" /sys/dev/char /sys/devices/pci*)
$(_bind_in_jail "ro-bind" /run/dbus /run/cups)
--symlink
/run
/var/run
$(_bind_in_jail "bind" "${_runtimedir}")
$(_block_in_jail "${_runtimedir}/app" "${_runtimedir}/doc")
$(_block_in_jail "${_runtimedir}/crun" "${_runtimedir}/containers" "${_runtimedir}/libpod")
$(_block_in_jail "${_runtimedir}/gnome-shell" "${_runtimedir}/gnupg" "${_runtimedir}"/gvfs*)
$(_block_in_jail "${_runtimedir}/keyring" "${_runtimedir}/p11-kit" "${_runtimedir}/systemd")
--bind
${_j_jail}/var/tmp
/var/tmp
${_j_home_binds}
${_j_sys_binds}
"

  # Set the IFS to newline only
  _old_ifs="${IFS}"
  IFS="${__NEWLINE_IFS}"

  # Assign the arguments to the "$@" array
  #
  # this will safely evaluate arguments with nested spaces without requiring eval
  #
  # shellcheck disable=SC2086
  set -- ${_j_all} ${_bwrap_args} '--' ${_j_cmd} ${_cmd_args}

  IFS="${_old_ifs}"
  unset _old_ifs

  _wrap "$@"
}

_check_prereq() {
  if ! command -v bwrap >/dev/null; then
    printf -- 'Must have "bwrap" installed.\n'
    return 1
  fi

  if ! command -v tr >/dev/null; then
    printf -- 'Must have "tr" installed.\n'
    return 1
  fi

  if ! command -v tac >/dev/null; then
    printf -- 'Must have "tac" installed.\n'
    return 1
  fi

  if ! command -v mkdir >/dev/null; then
    printf -- 'Must have "mkdir" installed.\n'
    return 1
  fi

  return 0
}

main() {
  _check_prereq || return 1
  _name=""
  _open_shell=0
  _use_x11=0
  _use_wayland=0

  # Assume the first argument is the command to run
  _cmd="$1"
  if [ -z "${_cmd}" ]; then
    printf -- 'Must provide command as first argument.\n'
    _usage
    return 1
  fi
  shift

  while [ -n "${_cmd}" ]; do
    case "${_cmd}" in
    -h | --help)
      # Show help
      _usage
      return 0
      ;;
    --shell)
      # We want to open a shell
      _open_shell=1

      # The next argument is the new command
      _cmd="$1"
      shift
      ;;
    --name)
      # We want a custom name
      _name="$1"

      # Shift because we consume the name
      shift

      # The next argument is the new command
      _cmd="$1"
      shift
      ;;
    --x11)
      # We need X11 compat
      _use_x11=1

      # The next argument is the new command
      _cmd="$1"
      shift
      ;;
    --wayland)
      # We need Wayland compat
      _use_wayland=1

      # The next argument is the new command
      _cmd="$1"
      shift
      ;;
    --)
      # Stop processing

      # The next argument is the new command
      _cmd="$1"
      shift

      break
      ;;
    *)
      # Show help
      _usage
      return 0
      ;;
    esac
  done

  # Double check the command here after all this proccessing
  if [ -z "${_cmd}" ]; then
    printf -- 'Must provide command as first argument.\n'
    _usage
    return 1
  fi

  if [ -z "${_name}" ]; then
    # Assume the jailname is the command name
    _name="${_cmd}"
  fi

  _jail_dir="${JAIL_DIR}/${_name}"
  _create_home "${_jail_dir}" || return 1
  _run_jail "${_cmd}" "${_jail_dir}" "${_name}" "${_open_shell}" "${_use_x11}" "${_use_wayland}" "$@" || return 1

  unset _use_wayland
  unset _use_x11
  unset _open_shell
  unset _cmd
  unset _jail_dir
  unset _name
  return 0
}

main "$@" || exit 1
exit 0
