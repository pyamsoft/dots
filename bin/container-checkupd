#!/bin/sh

readonly NAME="container-checkupd"

# Don't look up the same container but with different versions more than once
# This would happen if we were running hello-world:1 and pulled down hello-world:2
# which podman sees as 2 container images
__all_already_seen_containers=""

# rendercv - The image is not a "server" so we may not always have it, but still want to keep it up to date.
# httpie - The image is not a "server" so we may not always have it, but still want to keep it up to date.
readonly ADDITIONAL_CONTAINER_LOOKUP="ghcr.io/rendercv/rendercv
docker.io/alpine/httpie
"

_log() {
  _msg="$1"
  shift

  printf -- "[%s]: ${_msg}\n" "${NAME}" "$@" || return 1

  unset _msg
  return 0
}

_get_latest_tags() {
  _container="$1"

  if [ -z "${_container}" ]; then
    _log 'Missing required container name'
    unset _container
    return 1
  fi

  _log 'Container: %s' "${_container}"
  # Trim off the json, just get the list of tags
  # Remove anything like latest, beta, other unstable versions
  # Sort by reverse version order (newest version on top)
  # max 10

  skopeo list-tags "docker://${_container}" | tail -n +4 | head -n -2 | grep -v 'unstable' | grep -v 'beta' | grep -v 'staging' | grep -v 'nightly' | grep -v 'edge' | grep -v 'dev' | grep -v 'rc' | grep -v 'version' | grep -v 'arm64' | grep -v 'preview' | grep -v 'arm' | grep -v 'amd' |
    case "${_container}" in
    */littlelink-server)
      # Don't remove latest from littlelink, it only publishes latest
      cat
      ;;
    *)
      # Otherwise remove latest and let's keep going
      grep -v 'latest' |
        case "${_container}" in
        */rendercv)
          grep -v 'sha'
          ;;
        */unbound)
          grep -v 'openssl' | grep -v 'libevent' | grep -v 'canary'
          ;;
        */navidrome)
          grep -v 'sha' | grep -v 'pr-' | grep -v 'v0'
          ;;
        */beets)
          grep -v '2021.' | grep -v '\-ls'
          ;;
        */httpie)
          grep -v '3.5-0.9.9'
          ;;
        */jellyseerr)
          grep -v 'preview'
          ;;
        */jellyfin)
          grep -v '202.' | grep -v 'master'
          ;;
        */caddy)
          grep -v 'windows' | grep -v 'alpine' | grep -v 'builder'
          ;;
        */home-assistant)
          grep -v '.sig' | grep -v 'stable'
          ;;
        */esphome)
          grep -v 'b' | grep -v 'stable' | grep -v 'cache-release'
          ;;
        */omada-controller)
          grep -v 'chromium' | grep -v 'openj' | grep -v 'test'
          ;;
        */cloudflare-ddns)
          grep -v '.sig' | grep -v 'artifacthub'
          ;;
        */uptime-kuma)
          grep -v 'base' | grep -v 'push' | grep -v 'migrat' | grep -v 'builder' | grep -v 'alpine' | grep -v 'test' | grep -v 'debian'
          ;;
        */crowdsec)
          grep -v 'slim' | grep 'debian'
          ;;
        */scrutiny)
          grep 'omnibus'
          ;;
        */sonarr | */bazarr | */radarr | */prowlarr | */homeassistant | */qbittorrent)
          grep -v 'ls' | grep -v 'libtorrent'
          ;;
        */readarr)
          grep -v 'nightly' | grep -v 'amd64' | grep -v 'arm64'
          ;;
        */byparr)
          grep -v '.sig' | grep -v 'main'
          ;;
        */eclipse-mosquitto)
          grep -v 'openssl'
          ;;
        */zigbee2mqtt)
          grep -v 'v1.35' | grep -v 'v1.31'
          ;;
        *)
          cat
          ;;
        esac
      ;;
    esac | sort -r -V | head || {
    _log 'Failed to list most recent tags for: %s' "${_container}"
    unset _container
    return 1
  }

  unset _container
  return 0
}

_retrieve_latest_tags() {
  _tag_name="$1"

  if [ -z "${_tag_name}" ]; then
    _log 'Must provide container name to lookup tags'
    unset _tag_name
    return 1
  fi

  _skip=0

  # Check that we haven't already done this
  if [ -n "${__all_already_seen_containers}" ]; then
    for _c in ${__all_already_seen_containers}; do
      if [ "${_tag_name}" = "${_c}" ]; then
        _skip=1
        break
      fi
    done
  fi

  # Keep track
  if [ "${_skip}" -eq 0 ]; then
    if [ -z "${__all_already_seen_containers}" ]; then
      __all_already_seen_containers="${_tag_name}"
    else
      __all_already_seen_containers="${__all_already_seen_containers} ${_tag_name}"
    fi

    _get_latest_tags "${_tag_name}" || {
      unset _tag_name
      unset _skip
      return 1
    }
  fi

  unset _tag_name
  unset _skip
  return 0
}

_check_containers() {
  _cmd="$1"

  # A string of <name> <version> <name> <version>
  # shellcheck disable=SC2086
  _containers="$(${_cmd} images | grep -e '^docker\.io' -e '^ghcr\.io' | awk '{ printf $1 " " $2 " " }')"

  while :; do
    if [ -z "${_containers}" ]; then
      break
    fi

    _container_name="$(printf -- '%s' "${_containers}" | awk '{ print $1 }')"

    # Re-parse the containers output to move to the next container
    _containers="$(printf -- '%s' "${_containers}" | cut -f 3- -d ' ')"

    _retrieve_latest_tags "${_container_name}" || return 1
    unset _container_name
  done

  return 0
}

main() {
  _container_cmd=""
  if command -v podman >/dev/null 2>&1; then
    _container_cmd="podman"
  elif command -v docker >/dev/null 2>&1; then
    _container_cmd="docker"
  fi

  if [ -z "${_container_cmd}" ]; then
    _log 'Must install a container runner, either "podman" or "docker"'
    return 1
  fi

  # Our user
  _check_containers "${_container_cmd}" || {
    _log 'Failed checking containers for user'
    return 1
  }

  # Any containers delegates
  for _container_delegate_user in /home/containers-*; do
    _container_delegate_user="$(basename "${_container_delegate_user}")"

    # Check the delegated command exists
    if command -v "${_container_delegate_user}" >/dev/null 2>&1; then
      _check_containers "${_container_delegate_user}" || {
        _log 'Failed checking containers for delegate-user %s' "${_container_delegate_user}"
        return 1
      }
    fi

    unset _container_delegate_user
  done
  unset _container_delegate_user

  # Check again for root containers
  # We don't do this on MacOS since it runs a VM as root
  # Check only if our runner is podman, docker uses a root-daemon
  if [ "$(uname)" != "Darwin" ] && [ "${_container_cmd}" = "podman" ]; then
    _check_containers "sudo ${_container_cmd}" || {
      _log 'Failed checking containers for root'
      return 1
    }
  fi

  # Any additional containers
  if [ -n "${ADDITIONAL_CONTAINER_LOOKUP}" ]; then
    for _c in ${ADDITIONAL_CONTAINER_LOOKUP}; do
      _retrieve_latest_tags "${_c}" || {
        _log 'Failed checking for additional container: %s' "${_c}"

        unset _c
        return 1
      }
      unset _c
    done
    unset _c
  fi

  return 0
}

main "$@" || exit 1
exit 0
