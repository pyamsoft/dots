#!/bin/sh

# A simple jail which isolated user files from the greater HOME directory

readonly _VERSION="0.0.1"

# Can be overridden by the environment
readonly JAIL_DIR="${JAIL_DIR:-${HOME}/.local/etc/jails}"

_clean_path() {
  _current_path="${PATH}"

  # The .jail/bin dir holds alias scripts, we want to ignore
  # it when running this
  #
  # Reverse the path so we add back the paths in FIFO order
  _split_path="$(printf -- '%s' "${_current_path}" | tr ':' '\n' | tac)"
  _clean_path=""
  for _path in ${_split_path}; do
    if [ "${_path}" != "${HOME}/.jail/bin" ]; then
      if [ -z "${_clean_path}" ]; then
        _clean_path="${_path}"
      else
        _clean_path="${_path}:${_clean_path}"
      fi
    fi
  done

  PATH="${_clean_path}"
  export PATH
  return 0
}

_create_home() {
  _home="$1"

  # Create the jail root
  mkdir -p "${_home}/home" "${_home}/var/tmp" || {
    printf -- 'Failed to create jail dir: %s\n' "${_home}"

    unset _home
    return 1
  }

  unset _home
  return 0
}

# Bind a symlink into the jail, and resolve it's real path
_bind_symlink() {
  _bind_symlink_bind="$1"
  _bind_symlink_path="$2"

  if [ -L "${_bind_symlink_path}" ]; then
    _resolv_link="$(readlink "${_bind_symlink_path}")"
    _resolv_real_link="$(readlink -f "${_bind_symlink_path}")"

    printf -- '--%s %s %s ' "${_bind_symlink_bind}" "${_bind_symlink_path}" "${_resolv_link}"

    if [ "${_resolv_link}" != "${_resolv_real_link}" ]; then
      printf -- '--%s %s %s ' "${_bind_symlink_bind}" "${_resolv_link}" "${_resolv_real_link}"
    fi

    unset _resolv_link
    unset _resolv_real_link
  fi

  unset _bind_symlink_bind
  unset _bind_symlink_path
  return 0
}

_usage() {
  printf -- '%s\n' "$(
    cat <<EOF
jail [${_VERSION}]

Runs a command in a jail.
A jail separates the program's \${HOME} from the real user's \$HOME
directory.

Jails are located in: ${JAIL_DIR} by default


\$ jail [--shell] [--real-home] [--name <name>] <command> [bwrap-options] -- [command-options]

Any arguments passed after the <command> will be interpreted as options for bwrap.
Any arguments passed after the command and "--" will be passed to the command

[Options]
--name <name>    Name the jail (otherwise uses the command name)
--real-home      Do not jail directories in \$HOME
--shell          Open a shell in the jail instead of executing the command
-h | --help      Prints this help

EOF
  )"
}

##
# Bind to the same path in the jail
#
# $1 bind type bind|ro-bind|dev-bind
# $2.. path
_bind_in_jail() {
  _bind_type="$1"
  shift

  # No path provided, stop
  if [ -z "$1" ]; then
    return 1
  fi

  # Rest are paths
  for _path in "$@"; do
    if [ -e "${_path}" ]; then
      printf -- '--%s %s %s ' "${_bind_type}" "${_path}" "${_path}"
    fi
  done
  unset _path

  unset _bind_type
  return 0
}

##
# Block the path in the jail
#
# $1.. path
_block_in_jail() {
  # No path provided, stop
  if [ -z "$1" ]; then
    return 1
  fi

  # Rest are paths
  for _path in "$@"; do
    if [ -e "${_path}" ]; then
      printf -- '--tmpfs %s ' "${_path}"
    fi
  done
  unset _path

  return 0
}

_wrap() {
  # Log outputs, fail on anything
  set -xeu

  exec bwrap "$@"
}

_run_jail() {
  _j_cmd="$1"
  _j_jail="$2"
  _j_name="$3"
  _j_open_shell="$4"
  _j_real_home="$5"

  # The rest of the arguments are commands
  shift
  shift
  shift
  shift
  shift

  # Use a new session
  _j_session="--new-session"

  # If we are opening a shell, override the command
  # and keep current session
  if [ "${_j_open_shell}" -eq 1 ]; then
    _j_cmd="${SHELL:-/bin/bash}"
    _j_session=""
  fi
  unset _j_open_shell
  readonly _j_session
  readonly _j_cmd

  _clean_path || return 1

  _args=""
  for _a in "$@"; do
    if [ "${_a}" = "--" ]; then
      shift
      break
    fi

    if [ -z "${_args}" ]; then
      _args="$1"
    else
      _args="${_args} $1"
    fi
    shift
  done
  readonly _args

  if [ -n "${_j_real_home}" ] && [ "${_j_real_home}" -eq 1 ]; then
    printf -- 'Not jailing %s directory!\n' "\$HOME"
    _j_home_binds=""
  else
    _j_home_binds="--bind ${_j_jail}/home ${HOME} \
      $(_bind_in_jail "ro-bind" "${HOME}/.gnupg" "${GNUPGHOME}") \
      $(_bind_in_jail "ro-bind" "${HOME}/.themes" "${HOME}/.icons" "${HOME}/.fonts") \
      $(_bind_in_jail "ro-bind" "${XDG_CONFIG_HOME:-${HOME}/.config}"/fontconfig) \
      $(_bind_in_jail "ro-bind" "${XDG_CONFIG_HOME:-${HOME}/.config}"/gtk-*) \
      $(_bind_in_jail "ro-bind" "${XDG_CONFIG_HOME:-${HOME}/.config}"/QtProject.conf) \
      $(_bind_in_jail "bind" "${XDG_CONFIG_HOME:-${HOME}/.config}"/dconf) \
      $(_block_in_jail "${XDG_CONFIG_HOME:-${HOME}/.config}/ssh" "${HOME}/.ssh")"
  fi

  _j_sys_binds=""

  # If resolv conf is a symlink, bind the real file too
  _j_sys_binds="${_j_sys_binds} $(_bind_symlink "ro-bind" "/etc/resolv.conf")"

  readonly _j_home_binds
  readonly _j_sys_binds

  # Fail on subshell or pipe failure
  set -eu

  # unshare namespaces [don't unshare net (internet) and don't unshare IPC (x11)]
  # dev-bind root so everything works the same as it would outside
  # tmpfs bind /tmp for security
  # mount new proc on /proc
  # Mount a new home
  # Mark the process
  #
  # Unset the SESSION_MANAGER var
  # https://stackoverflow.com/questions/59057653/qt-session-management-error-none-of-the-authentication-protocols-specified-are
  #
  # Overwrite /tmp /run /var and /proc
  # /sys is overwritten but the char and pci devices are mounted back in for 3d accel
  # Mount back the user runtime dir and add extra binds for .X11 in /tmp
  # Mount dbus system socket
  # Mount cups socket
  #
  # shellcheck disable=SC2086,SC2046
  _wrap \
    ${_j_session} \
    --unshare-user \
    --unshare-ipc \
    --unshare-pid \
    --unshare-uts \
    --unshare-cgroup \
    --setenv JAIL_PID "$$" \
    --setenv JAIL_NAME "${_j_name}" \
    --setenv JAIL_PROGRAM "${_j_cmd}" \
    --unsetenv SESSION_MANAGER \
    $(_bind_in_jail "dev-bind" "/") \
    --proc /proc \
    --mqueue /dev/mqueue \
    $(_block_in_jail "/boot" "/run" "/tmp" "/var" "/sys") \
    $(_block_in_jail "/usr/lib/modules" "/usr/lib/modprobe.d" "/usr/lib/modules-load.d") \
    $(_block_in_jail "/usr/share/iptables" "/usr/share/nftables" "/usr/share/firewalld") \
    $(_block_in_jail "/usr/share/polkit-1") \
    $(_block_in_jail "/usr/share/flatpak") \
    $(_block_in_jail "/usr/lib/udev" "/usr/lib/sudo" "/usr/lib/sysctl.d") \
    $(_block_in_jail "/usr/lib/sunshine") \
    $(_block_in_jail "/usr/lib/systemd") \
    $(_block_in_jail "/etc/kernel" "/etc/keyutils") \
    $(_block_in_jail "/etc/modprobe.d" "/etc/modules-load.d") \
    $(_block_in_jail "/etc/credstore" "/etc/credstore.encrypted") \
    $(_block_in_jail "/etc/iptables" "/etc/firewalld" "/etc/firewall") \
    $(_block_in_jail "/etc/polkit-1" "/etc/udev") \
    $(_block_in_jail "/etc/sudoers.d" "/etc/sysctl.d") \
    $(_block_in_jail "/etc/systemd") \
    $(_block_in_jail "/etc/flatpak") \
    $(_block_in_jail "/etc/ssh") \
    $(_block_in_jail "/etc/crypttab" "/etc/cryptsetup-keys.d/") \
    $(_block_in_jail "/etc/fstab") \
    $(_bind_in_jail "dev-bind" /sys/dev/char /sys/devices/pci*) \
    $(_bind_in_jail "bind" /tmp/.X*-lock /tmp/.*-unix) \
    $(_bind_in_jail "ro-bind" /run/dbus /run/cups) \
    $(_bind_in_jail "bind" "${XDG_RUNTIME_DIR:-/run/user/$(id -u)}") \
    --bind "${_j_jail}/var/tmp" "/var/tmp" \
    ${_j_home_binds} \
    ${_j_sys_binds} \
    ${_args} -- "${_j_cmd}" "$@"
}

_check_prereq() {
  if ! command -v bwrap >/dev/null; then
    printf -- 'Must have "bwrap" installed.\n'
    return 1
  fi

  if ! command -v tr >/dev/null; then
    printf -- 'Must have "tr" installed.\n'
    return 1
  fi

  if ! command -v tac >/dev/null; then
    printf -- 'Must have "tac" installed.\n'
    return 1
  fi

  if ! command -v mkdir >/dev/null; then
    printf -- 'Must have "mkdir" installed.\n'
    return 1
  fi

  return 0
}

main() {
  _check_prereq || return 1
  _name=""
  _open_shell=0
  _real_home=0

  # Assume the first argument is the command to run
  _cmd="$1"
  if [ -z "${_cmd}" ]; then
    printf -- 'Must provide command as first argument.\n'
    _usage
    return 1
  fi
  shift

  # Show help
  if [ "${_cmd}" = "--help" ] || [ "${_cmd}" = "-h" ]; then
    _usage
    return 1
  fi

  # If we want to open a shell, then the next thing is the command
  if [ "${_cmd}" = "--shell" ]; then
    # We want to open a shell
    _open_shell=1

    # The next argument is the new command
    _cmd="$1"
    shift
  else
    _open_shell=0
  fi

  # We want to use the real home
  if [ "${_cmd}" = "--real-home" ]; then
    # Do not jail home
    _real_home=1

    # The next argument is the new command
    _cmd="$1"
    shift
  fi

  # If we provide a name, use it instead of the command name
  if [ "${_cmd}" = "--name" ]; then
    # We've shifted, the current argument is the name
    _name="$1"
    shift

    # The next argument is the new command
    _cmd="$1"
    shift
  else
    _name="${_cmd}"
  fi

  # Double check the command here after all this proccessing
  if [ -z "${_cmd}" ]; then
    printf -- 'Must provide command as first argument.\n'
    _usage
    return 1
  fi

  _jail_dir="${JAIL_DIR}/${_name}"
  _create_home "${_jail_dir}" || return 1
  _run_jail "${_cmd}" "${_jail_dir}" "${_name}" "${_open_shell}" "${_real_home}" "$@" || return 1

  unset _real_home
  unset _open_shell
  unset _cmd
  unset _jail_dir
  unset _name
  return 0
}

main "$@" || exit 1
exit 0
