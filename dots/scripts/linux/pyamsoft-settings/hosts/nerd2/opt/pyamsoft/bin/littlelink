#!/bin/sh

# Source our common library
. "/opt/pyamsoft/lib/container-launch"

NAME="littlelink"
IMAGE="ghcr.io/techno-tim/littlelink-server"
TAG="latest"

CONTAINER_REQUIRE_INIT=1

_prep_mounts() {
  _mount_mkdir "${CONTAINER_RUNTIME_DIR}/${NAME}/data" || return 1

  return 0
}

_prep_env() {
  CONTAINER_ENV="${CONTAINER_ENV} -e META_INDEX_STATUS=noindex"
  CONTAINER_ENV="${CONTAINER_ENV} -e LANG=en"
  CONTAINER_ENV="${CONTAINER_ENV} -e THEME=Dark"
  CONTAINER_ENV="${CONTAINER_ENV} -e THEME_OS=true"

  return 0
}

_prep_network() {
  # Attach our isolated network
  #
  # We shouldn't need to care about source IP addresses here as this website is proxied through Cloudflare
  # so their protections should generally handle it. Plus there are no specific log drivers in Crowdsec that
  # need to read these logs to identify bad actors.
  _network_isolate || return 1

  return 0
}

_prep_caps() {
  return 0
}

_prep_ports() {
  CONTAINER_PORTS="${CONTAINER_PORTS} -p 127.0.0.1:8420:3000/tcp"
  return 0
}

_check_user() {
  if [ "$(id -u)" -eq 0 ]; then
    _log 'You must run this as a rootless container'
    return 1
  fi

  return 0
}

_containerize() {
  # Log the commands we use next
  # Fail on errors
  # Fail on unassigned
  set -xeu

  # You need to add a CUSTOM_BUTTON_* for each new link
  # All CUSTOM_BUTTON_* FIELDS REQUIRED

  # Don't quote so that if user is empty it still expands
  #
  # shellcheck disable=SC2086
  exec ${CONTAINER_CMD} run --rm \
    --name "${NAME}" --hostname "${NAME}" \
    --security-opt no-new-privileges:true --cap-drop ALL \
    --pull=newer \
    --init \
    ${CONTAINER_RC} \
    ${CONTAINER_LOGS} \
    ${CONTAINER_NETWORK} \
    ${CONTAINER_ENV} \
    ${CONTAINER_MOUNTS} \
    ${CONTAINER_PORTS} \
    ${CONTAINER_CAPS} \
    ${CONTAINER_USERNS} \
    "${IMAGE}:${TAG}" "$@"
}

main() {
  _check_user || return 1
  _prep_mounts || return 1
  _prep_ports || return 1
  _prep_caps || return 1
  _prep_env || return 1
  _prep_network || return 1
  _prep_log || return 1

  "${_cmd}" --version >/dev/null 2>&1 || {
    _log 'Unable to check %s version.' "${_cmd}"
    return 1
  }

  # Wait for the ${XDG_RUNTIME_DIR}/podman folder to be available before launching
  # This folder is created "at some point" in response to podman commands being run
  if [ "$(uname)" = "Linux" ] && [ "${_cmd}" = "podman" ]; then
    while [ ! -d "${XDG_RUNTIME_DIR}/containers" ]; do
      sleep 1 || {
        _log 'Cancelled while waiting for container runtime to stand up.'
        return 1
      }
    done
    _log 'Container runtime is ready, start %s' "${_name}"
  fi

  _containerize "$@" || return 1
  return 0
}

main "$@" || exit 1
exit 0
