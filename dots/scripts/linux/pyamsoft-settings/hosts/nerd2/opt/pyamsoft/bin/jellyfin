#!/bin/sh

# Source our common library
. "/opt/pyamsoft/lib/container-launch"

NAME="jellyfin"
IMAGE="docker.io/jellyfin/jellyfin"
TAG="10.11.5"

CONTAINER_MEMORY_LIMIT="4G"

# Require a VPN unless you absolutely know what you are doing
readonly REQUIRE_VPN="${REQUIRE_VPN:-1}"

_prep_mounts() {
  _mount_bind "${CONTAINER_RUNTIME_DIR}/${NAME}/cache" "/cache" || return 1
  _mount_bind "${CONTAINER_RUNTIME_DIR}/${NAME}/transcodes" "/.cache" || return 1
  _mount_bind "${CONTAINER_RUNTIME_DIR}/${NAME}/config" "/config" || return 1

  # Media folders are optionally symlinks to another mass storage drive
  _media="${CONTAINER_RUNTIME_DIR}/${NAME}/media"
  _mount_mkdir "${_media}"

  # Follow the link and mount the media folder ONLY if it is valid
  if [ -d "$(realpath "${_media}")" ]; then
    _add_mounts --mount "type=bind,source=${_media},target=/media"
  fi
  unset _media

  return 0
}

_prep_caps() {
  return 0
}

_prep_ports() {
  _add_ports -p "127.0.0.1:8096:8096/tcp"
  return 0
}

_get_gid_for_group() {
  _grp="$1"
  _gid="$(getent group "${_grp}" | cut -d : -f 3)"

  printf -- '%s' "${_gid}"

  unset _grp
  unset _gid
  return 0
}

_prep_env() {
  return 0
}

_prep_network() {
  if [ -n "${USE_VPN}" ] && [ "${USE_VPN}" -ne 0 ]; then
    # Don't add the host routing when using a VPN
    CONTAINER_NETWORK_HOST_ROUTE=0

    # We have optional support for a wireguard VPN container
    _add_network --network "container:wireguard"
  else
    # Require a VPN
    if [ -n "${REQUIRE_VPN}" ] && [ "${REQUIRE_VPN}" -eq 1 ]; then
      _log 'You MUST use a VPN connection to run %s' "${NAME}"
      return 1
    fi

    # We continue using the DEFAULT network instead of creating our own.
    # The default network uses the a special setup of the bridge driver
    # which preserves source IP addresses
    #
    # We need to preserve source IP address so that Crowdsec can operate on bad actors
    #
    # However as a trade off, since this runs on the default bridge this decreases network isolation.
  fi

  return 0
}

_check_user() {
  _require_nonroot || return 1

  # Only for podman
  if _is_podman; then
    # Need this userns option that is podman specific or we have random OCI permission error
    _add_userns --userns keep-id
  fi

  return 0
}

_finalize() {
  # Needed for GPU rendering
  _add_rc --device "/dev/dri:/dev/dri"
  _add_rc --group-add="$(_get_gid_for_group "render")"
  _add_rc --group-add="$(_get_gid_for_group "video")"
  return 0
}

main "$@" || exit 1
exit 0
