#!/bin/sh

NAME="${NAME:-}"
IMAGE="${IMAGE:-}"
TAG="${TAG:-}"

# Fail if a runconfig is not provided. If 0, suggest an optional runconfig location
CONTAINER_REQUIRE_RUNCONF="${CONTAINER_REQUIRE_RUNCONF:-1}"
# Run the container with --init
CONTAINER_REQUIRE_INIT="${CONTAINER_REQUIRE_INIT:-0}"
# Add host gateway, disable if custom networking
CONTAINER_NETWORK_HOST_ROUTE="${CONTAINER_NETWORK_HOST_ROUTE:-1}"
# Run the container network with IPv6 if using a custom isolated network
CONTAINER_NETWORK_IP6="${CONTAINER_NETWORK_IP6:-0}"
# The amount of memory a container can use
CONTAINER_MEMORY_LIMIT="${CONTAINER_MEMORY_LIMIT:-}"
# Pull policy
CONTAINER_PULL_POLICY="${CONTAINER_PULL_POLICY:-}"
# Custom Entrypoint
CONTAINER_ENTRYPOINT="${CONTAINER_ENTRYPOINT:-}"
# Read only root filesystem
CONTAINER_READONLY="${CONTAINER_READONLY:-0}"
# Use the "unique" name instead of adopting $NAME
CONTAINER_UNIQUE_NAME="${CONTAINER_UNIQUE_NAME:-0}"

# Will be evaluated once main() is ran
CONTAINER_RUNTIME_DIR=""
CONTAINER_NETWORK=""
CONTAINER_ENV=""
CONTAINER_MOUNTS=""
CONTAINER_PORTS=""
CONTAINER_CAPS=""
CONTAINER_USERNS=""
CONTAINER_RC=""
CONTAINER_LOGS=""
CONTAINER_MEMORY=""
CONTAINER_CPU=""
CONTAINER_CMD=""
CONTAINER_ARGS=""

## Defaults

## Private variables
__os_name="$(uname)"
__uid="$(id -u)"

## Check host user is root
_is_root() {
  [ "${__uid}" -eq 0 ]
}

## Check host is running Linux
_is_linux() {
  [ "${__os_name}" = "Linux" ]
}

## Check host is MacOS
_is_macos() {
  [ "${__os_name}" = "Darwin" ]
}

## Check if container is "podman"
_is_podman() {
  [ "${CONTAINER_CMD}" = "podman" ]
}

## Check if container is "docker"
_is_docker() {
  [ "${CONTAINER_CMD}" = "docker" ]
}

## Check if CMD is atleast version "$1"
_is_cmd_version_atleast() {
  _expect_v="$1"

  _has_v_array="$("${CONTAINER_CMD}" --version | grep -o '[0-9][0-9]*\(\.[0-9][0-9]*\)\{1,2\}' | tr '.' ' ')"
  _exp_v_array="$(printf -- '%s' "${_expect_v}" | tr '.' ' ')"

  _has_v_major="$(printf -- '%s' "${_has_v_array}" | awk '{ print $1 }')"
  _has_v_minor="$(printf -- '%s' "${_has_v_array}" | awk '{ print $2 }')"
  _has_v_patch="$(printf -- '%s' "${_has_v_array}" | awk '{ print $3 }')"

  _exp_v_major="$(printf -- '%s' "${_exp_v_array}" | awk '{ print $1 }')"
  _exp_v_minor="$(printf -- '%s' "${_exp_v_array}" | awk '{ print $2 }')"
  _exp_v_patch="$(printf -- '%s' "${_exp_v_array}" | awk '{ print $3 }')"

  if [ -n "${_has_v_major}" ] && [ -n "${_exp_v_major}" ]; then
    # If our current version MAJOR is less than we expect, fail
    if [ "${_has_v_major}" -lt "${_exp_v_major}" ]; then
      unset _exp_v_major
      unset _exp_v_minor
      unset _exp_v_patch
      unset _exp_v_array

      unset _has_v_major
      unset _has_v_minor
      unset _has_v_patch
      unset _has_v_array

      unset _expect_v
      return 1
    fi
  fi

  if [ -n "${_has_v_minor}" ] && [ -n "${_exp_v_minor}" ]; then
    # If our current version MINOR is less than we expect, fail
    if [ "${_has_v_minor}" -lt "${_exp_v_minor}" ]; then
      unset _exp_v_major
      unset _exp_v_minor
      unset _exp_v_patch
      unset _exp_v_array

      unset _has_v_major
      unset _has_v_minor
      unset _has_v_patch
      unset _has_v_array

      unset _expect_v
      return 1
    fi
  fi

  if [ -n "${_has_v_patch}" ] && [ -n "${_exp_v_patch}" ]; then
    # If our current version PATCH is less than we expect, fail
    if [ "${_has_v_patch}" -lt "${_exp_v_patch}" ]; then
      unset _exp_v_major
      unset _exp_v_minor
      unset _exp_v_patch
      unset _exp_v_array

      unset _has_v_major
      unset _has_v_minor
      unset _has_v_patch
      unset _has_v_array

      unset _expect_v
      return 1
    fi
  fi

  # Otherwise we are good
  unset _exp_v_major
  unset _exp_v_minor
  unset _exp_v_patch
  unset _exp_v_array

  unset _has_v_major
  unset _has_v_minor
  unset _has_v_patch
  unset _has_v_array

  unset _expect_v
  return 0
}

##
# Add to MOUNTS
_add_mounts() {
  for _arg in "$@"; do
    CONTAINER_MOUNTS="${CONTAINER_MOUNTS}
${_arg}"
    unset _arg
  done
  unset _arg

  return 0
}

##
# Add to NETWORK
_add_network() {
  for _arg in "$@"; do
    CONTAINER_NETWORK="${CONTAINER_NETWORK}
${_arg}"
    unset _arg
  done
  unset _arg

  return 0
}

##
# Add to ENV
_add_env() {
  for _arg in "$@"; do
    CONTAINER_ENV="${CONTAINER_ENV}
${_arg}"
    unset _arg
  done
  unset _arg

  return 0
}

##
# Add to PORTS
_add_ports() {
  for _arg in "$@"; do
    CONTAINER_PORTS="${CONTAINER_PORTS}
${_arg}"
    unset _arg
  done
  unset _arg

  return 0
}

##
# Add to CAPS
_add_caps() {
  for _arg in "$@"; do
    CONTAINER_CAPS="${CONTAINER_CAPS}
${_arg}"
    unset _arg
  done
  unset _arg

  return 0
}

##
# Add to CAPS
_add_userns() {
  for _arg in "$@"; do
    CONTAINER_USERNS="${CONTAINER_USERNS}
${_arg}"
    unset _arg
  done
  unset _arg

  return 0
}

##
# Add to RC
_add_rc() {
  for _arg in "$@"; do
    CONTAINER_RC="${CONTAINER_RC}
${_arg}"
    unset _arg
  done
  unset _arg

  return 0
}

##
# Add to MEMORY
_add_memory() {
  for _arg in "$@"; do
    CONTAINER_MEMORY="${CONTAINER_MEMORY}
${_arg}"
    unset _arg
  done
  unset _arg

  return 0
}

##
# Add to CPU
_add_cpu() {
  for _arg in "$@"; do
    CONTAINER_CPU="${CONTAINER_CPU}
${_arg}"
    unset _arg
  done
  unset _arg

  return 0
}

##
# Add to LOGS
_add_logs() {
  for _arg in "$@"; do
    CONTAINER_LOGS="${CONTAINER_LOGS}
${_arg}"
    unset _arg
  done
  unset _arg

  return 0
}

##
# Add to RC
_add_args() {
  for _arg in "$@"; do
    CONTAINER_ARGS="${CONTAINER_ARGS}
${_arg}"
    unset _arg
  done
  unset _arg

  return 0
}

_require_root() {
  if ! _is_root; then
    _elog 'You must run this as a rootfull container'
    return 1
  fi

  return 0
}

_require_nonroot() {
  if _is_root; then
    _elog 'You must run this as a rootless container'
    return 1
  fi

  return 0
}

##
# Logs a message with newline, formatting, and a name tag
_log() {
  _msg="$1"
  shift

  printf -- "[%s]: ${_msg}\n" "${NAME}" "$@" || return 1

  unset _msg
  return 0
}

##
# Log a message to stderr
_elog() {
  _log "$@" 1>&2 || return 1
  return 0
}

##
# Ensure a function or command is defined
_has_function() {
  command -v "$1" >/dev/null 2>&1
}

##
# Create a new isolated bridge network
_network_isolate() {
  _network_name="${1:-${NAME}}"

  # Create our own network
  if _is_podman; then
    # Podman can "ignore" networks with the same name
    if [ "${CONTAINER_NETWORK_IP6}" -ne 0 ]; then
      "${CONTAINER_CMD}" network create --ignore --driver bridge --opt isolate=true --disable-dns --ipv6 -- "${_network_name}" >/dev/null || {
        _elog "Failed to create isolated network using %s -> %s" "${CONTAINER_CMD}" "${_network_name}"
        unset _network_name
        return 1
      }
    else
      "${CONTAINER_CMD}" network create --ignore --driver bridge --opt isolate=true --disable-dns -- "${_network_name}" >/dev/null || {
        _elog "Failed to create isolated network using %s -> %s" "${CONTAINER_CMD}" "${_network_name}"

        unset _network_name
        return 1
      }
    fi
  else
    # Docker must make sure the network doesn't already exist
    if ! "${CONTAINER_CMD}" network ls --format '{{.Name}}' | grep -q "${_network_name}"; then
      if [ "${CONTAINER_NETWORK_IP6}" -ne 0 ]; then
        "${CONTAINER_CMD}" network create --driver bridge --opt com.docker.network.bridge.enable_icc=false --ipv6 -- "${_network_name}" >/dev/null || {
          _elog "Failed to create isolated network using %s -> %s" "${CONTAINER_CMD}" "${_network_name}"

          unset _network_name
          return 1
        }
      else
        "${CONTAINER_CMD}" network create --driver bridge --opt com.docker.network.bridge.enable_icc=false -- "${_network_name}" >/dev/null || {
          _elog "Failed to create isolated network using %s -> %s" "${CONTAINER_CMD}" "${_network_name}"

          unset _network_name
          return 1
        }
      fi
    fi
  fi

  # Attach our isolated network
  _add_network --network="${_network_name}"

  unset _network_name
  return 0
}

##
# Make a directory on the host
_host_mkdir() {
  _mount_d="$1"

  mkdir -p "${_mount_d}" || {
    _elog "Failed to create mount source %s" "${_mount_d}"

    unset _mount_d
    return 1
  }

  unset _mount_d
  return 0
}

##
# chmod a file or directory on the host
_host_chmod() {
  _chmod_mode="$1"
  _chmod_target="$2"

  chmod -R "${_chmod_mode}" "${_chmod_target}" || {
    _elog "Failed to chmod host directory %s (%s)" "${_chmod_target}" "${_chmod_mode}"
    unset _chmod_mode
    unset _chmod_target
    return 1
  }

  unset _chmod_mode
  unset _chmod_target
  return 0
}

##
# Bind most a host directory
_mount_bind() {
  _mount_src="$1"
  _mount_target="$2"
  _mount_options="$3"

  _host_mkdir "${_mount_src}" || {
    unset _mount_src
    unset _mount_target
    unset _mount_options
    return 1
  }

  if [ -n "${_mount_options}" ]; then
    _add_mounts --mount "type=bind,source=${_mount_src},target=${_mount_target},${_mount_options}"
  else
    _add_mounts --mount "type=bind,source=${_mount_src},target=${_mount_target}"
  fi

  unset _mount_src
  unset _mount_target
  unset _mount_options
  return 0
}

##
# Private
__require_function() {
  if ! _has_function "$1"; then
    _elog 'Function is required: %s' "$1"
    return 1
  fi

  return 0
}

##
# Private
__setup_network() {
  _prep_network || return 1

  # Evaluate this AFTER so that just incase the script
  # has changed CONTAINER_NETWORK_HOST_ROUTE from _prep_network, we will pick it up
  if [ "${CONTAINER_NETWORK_HOST_ROUTE}" ] && [ "${CONTAINER_NETWORK_HOST_ROUTE}" -ne 0 ]; then
    _add_network --dns-option="edns0,trust-ad"
    _add_network --dns-search="."
    _add_network --add-host "localhost:127.0.0.1"
    _add_network --add-host "host.containers.internal:host-gateway"
    _add_network --add-host "host.docker.internal:host-gateway"
  fi

  return 0
}

##
# Private
__await_directory() {
  _awaiting="$1"
  if [ -z "${_awaiting}" ]; then
    _elog 'Must provide directory to await'
    return 1
  fi

  # Run a simple version command which should "start" the podman container runtime directory
  "${CONTAINER_CMD}" --version >/dev/null 2>&1 || {
    _elog 'Unable to check %s version.' "${CONTAINER_CMD}"
    return 1
  }

  if _is_linux && _is_podman; then
    # Wait for the podman folder to be available before launching
    # This folder is created "at some point" in response to podman commands being run
    while [ ! -d "${_awaiting}" ]; do
      sleep 1 || {
        _elog 'Cancelled while waiting for container runtime to stand up at %s' "${_awaiting}"

        unset _awaiting
        return 1
      }
    done
    _log 'Container runtime is ready at %s: start %s' "${_awaiting}" "${NAME}"
  fi

  unset _awaiting
  return 0
}

##
# Overridable
#
# Default function for setting up Memory usage
_prep_memory() {
  if [ -n "${CONTAINER_MEMORY_LIMIT}" ]; then
    _elog 'Setting container memory limit for %s directly is deprecated. Containers will always use MAX-20%%' "${NAME}"
  fi

  # Grab the total amount of RAM available to the system
  _total_ram_mb="$(free -m | grep '^Mem:' | awk '{ print $2 }')"
  _leave_free="$((_total_ram_mb * 2 / 10))"

  _add_memory --memory "$((_total_ram_mb - _leave_free))M"

  unset _total_ram_mb
  unset _leave_free

  return 0
}

##
# Overridable
#
# Default function for setting up CPU usage
_prep_cpu() {
  return 0
}

##
# Overridable
#
# Default function for setting up system logging
_prep_log() {
  # On Linux, our user session executes from systemd and thus sets the systemd vars
  # like JOURNAL_STREAM and INVOCATION_ID
  #
  # We cannot reliably use them to sniff "am I being ran by systemd"
  #
  # As such our services set a special PYAM_SYSTEMD variable and we sniff that
  if _is_linux && [ -n "${PYAM_SYSTEMD}" ]; then
    if _is_podman; then
      _add_logs --log-driver json-file
    fi
  else
    _add_logs -i
    _add_logs -t
  fi

  return 0
}

##
# Overridable
#
# Default function for sourcing a run configuration
_prep_rc() {
  # Source the runtime config (so we don't have to hardcode keys)
  _runconf="${CONTAINER_RUNTIME_DIR}/${NAME}/runconfig.env"
  if [ -n "${CONTAINER_REQUIRE_RUNCONF}" ] && [ "${CONTAINER_REQUIRE_RUNCONF}" -ne 0 ]; then
    if [ ! -e "${_runconf}" ]; then
      _elog 'You must provide %s' "${_runconf}"
      return 1
    fi
  else
    if [ ! -e "${_runconf}" ]; then
      _log 'Optional runconf supported at %s' "${_runconf}"
    fi
  fi

  if [ -e "${_runconf}" ]; then
    # Source the file into the environment
    # shellcheck disable=SC1090
    . "${_runconf}" || {
      _elog 'Unable to source runconfig %s' "${_runconf}"
      return 1
    }
  fi
  unset _runconf

  return 0
}

##
# Overridable
#
# Last minute changes
_finalize() {
  return 0
}

##
# Overridable
#
# Default execution function
# Restricts capabilities, privileges, and ensures the container is named and removed after execution
_containerize() {
  # Parse the args in a way we expect
  for _arg in "$@"; do
    _add_args "${_arg}"
    unset _arg
  done
  unset _arg

  if [ -n "${CONTAINER_REQUIRE_INIT}" ] && [ "${CONTAINER_REQUIRE_INIT}" -ne 0 ]; then
    _add_rc --init
  fi

  if [ -n "${CONTAINER_READONLY}" ] && [ "${CONTAINER_READONLY}" -ne 0 ]; then
    _add_rc --read-only
  fi

  if [ -n "${CONTAINER_ENTRYPOINT}" ]; then
    _add_rc --entrypoint="${CONTAINER_ENTRYPOINT}"
  fi

  if [ -n "${CONTAINER_PULL_POLICY}" ]; then
    _add_rc --pull="${CONTAINER_PULL_POLICY}"
  fi

  # Set hostname
  _add_rc --hostname="${NAME}"

  # Set a standard name if we do NOT want a unique one
  if [ -z "${CONTAINER_UNIQUE_NAME}" ] || [ "${CONTAINER_UNIQUE_NAME}" -eq 0 ]; then
    _add_rc --name="${NAME}"
  fi

  # Breaks on MacOS with a complaint about "unrecognized key ''"
  if _is_linux; then
    # Disable detach keys
    _add_rc --detach-keys=""
  fi

  # Security
  _add_rc --cap-drop=ALL
  _add_rc --security-opt=no-new-privileges

  if _is_podman; then
    if _is_cmd_version_atleast 5.4; then
      # Slightly increase security by starting with a blank hosts file
      _add_network --hosts-file="none"
    fi
  fi

  # Make the IFS into newline only so we can correctly parse arguments with embedded spaces
  IFS='
'

  # Log the commands we use next
  # Fail on errors
  # Fail on unassigned
  set -xeu

  # Don't quote so that if user is empty it still expands
  #
  # shellcheck disable=SC2086
  exec "${CONTAINER_CMD}" \
    run \
    --rm \
    ${CONTAINER_RC} \
    ${CONTAINER_MEMORY} \
    ${CONTAINER_CPU} \
    ${CONTAINER_LOGS} \
    ${CONTAINER_NETWORK} \
    ${CONTAINER_ENV} \
    ${CONTAINER_MOUNTS} \
    ${CONTAINER_PORTS} \
    ${CONTAINER_CAPS} \
    ${CONTAINER_USERNS} \
    "${IMAGE}:${TAG}" \
    ${CONTAINER_ARGS}
}

main() {
  # Reset
  CONTAINER_CMD=""
  CONTAINER_LOGS=""
  CONTAINER_RC=""
  CONTAINER_RUNTIME_DIR=""
  CONTAINER_NETWORK=""
  CONTAINER_ENV=""
  CONTAINER_MOUNTS=""
  CONTAINER_PORTS=""
  CONTAINER_CAPS=""
  CONTAINER_USERNS=""
  CONTAINER_MEMORY=""
  CONTAINER_CPU=""
  CONTAINER_ARGS=""

  if [ -z "${NAME}" ]; then
    # shellcheck disable=SC2016
    printf -- '[container-launch] $NAME must be defined\n'
    return 1
  fi

  if [ -z "${IMAGE}" ]; then
    # shellcheck disable=SC2016
    _elog '$IMAGE must be defined'
    return 1
  fi

  if [ -z "${TAG}" ]; then
    # shellcheck disable=SC2016
    _elog '$TAG must be defined'
    return 1
  fi

  # Use podman, don't use docker
  if _has_function podman; then
    CONTAINER_CMD="podman"
  elif _has_function docker; then
    CONTAINER_CMD="docker"
  else
    _elog 'Requires either "podman" or "docker" ("podman" preferred)'
    exit 1
  fi

  readonly CONTAINER_CMD

  # Move to accessible directory
  if _is_root; then
    _watch="/run/containers"
    CONTAINER_RUNTIME_DIR="/usr/local/etc/containers"

    cd / || {
      _elog 'Unable to move into / directory'
      return 1
    }
  else
    _watch="${XDG_RUNTIME_DIR}/containers"
    CONTAINER_RUNTIME_DIR="${HOME}/.local/etc/containers"

    cd "${HOME}" || {
      _elog 'Unable to move into HOME directory'
      return 1
    }
  fi

  __require_function _check_user || return 1
  _check_user || return 1

  __require_function _prep_mounts || return 1
  _prep_mounts || return 1

  __require_function _prep_ports || return 1
  _prep_ports || return 1

  __require_function _prep_caps || return 1
  _prep_caps || return 1

  __require_function _prep_network || return 1
  __setup_network || return 1

  __require_function _prep_env || return 1
  _prep_env || return 1

  # These are defined here an while they can be overridden, they should
  # always exist
  _prep_cpu || return 1
  _prep_memory || return 1
  _prep_log || return 1
  _prep_rc || return 1

  __await_directory "${_watch}" || return 1
  _finalize "$@" || return 1

  _containerize "$@" || return 1
  return 0
}
