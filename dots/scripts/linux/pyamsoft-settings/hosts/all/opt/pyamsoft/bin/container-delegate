#!/bin/sh

_PROG_NAME="$(basename "$0")"
readonly _PROG_NAME

__containers=
__args=""

# Use podman, don't use docker
if command -v podman >/dev/null; then
  _cmd="podman"
elif command -v docker >/dev/null; then
  _cmd="docker"
else
  printf -- 'Requires either "podman" or "docker" ("podman" preferred)\n'
  exit 1
fi
readonly _cmd

_dotfiles() {
  exec git --git-dir "${HOME}"/.dotfiles --work-tree "${HOME}" "$@"
}

_usage() {
  printf -- '%s\n' "$(
    cat <<EOF

($(id -un)) ${_PROG_NAME} <action>

<actions>

[container]:   Exectue ${_cmd} operations on containers

  pid          Returns the PID of the containerized process on the host system
  ps           Runs '${_cmd} ps', passing all arguments
  logs         Runs '${_cmd} logs', passing all arguments
  images       Runs '${_cmd} images', passing all arguments
  inspect      Runs '${_cmd} inspect', passing all arguments
  stats        Runs '${_cmd} stats', passing all arguments

[service]:     Service management related operations

  reload       Runs 'systemctl --user daemon-reload'
  disable      Runs 'systemctl --user disable --now container@<name>'
  restart      Runs 'systemctl --user restart container@<name>'
  status       Runs 'systemctl --user status container@<name>'
  stop         Runs 'systemctl --user stop container@<name>'

[system]:      System management related operations

  checkup      Runs 'podman auto-update --dry-run' ("podman" ONLY)
  exec         Runs '${_cmd} exec -it <name>'
  prune        Runs '${_cmd} system prune -a'
  pull         Runs 'dotfiles pull'
  teardown     Runs 'container-teardown <name>'

EOF
  )"
}

_prep_container() {
  # Since the containers user lingers, we assume the XDG_RUNTIME_DIR exists, but it's not set in this sudo shell
  # So we manually set it and then call systemctl
  XDG_RUNTIME_DIR="/run/user/$(id -u)"
  export XDG_RUNTIME_DIR

  return 0
}

_collect_containers() {

  for _c in "$@"; do
    if [ -z "${__containers}" ]; then
      case "$1" in
      -*)
        if [ -z "${__args}" ]; then
          __args="$1"
        else
          __args="${__args} $1"
        fi
        ;;
      *)
        if [ -z "${__containers}" ]; then
          __containers="container@$1"
        else
          __containers="${__containers} container@$1"
        fi
        ;;
      esac
    else
      case "$1" in
      -*)
        if [ -z "${__args}" ]; then
          __args="$1"
        else
          __args="${__args} $1"
        fi
        ;;
      *)
        # In order
        if [ -z "${__containers}" ]; then
          __containers="container@$1"
        else
          __containers="${__containers} container@$1"
        fi
        ;;
      esac
    fi
    unset _c

    shift
  done
  unset _c

  return 0
}

main() {
  if [ -z "$1" ]; then
    _usage || return 1
    return 1
  fi

  # Podman expects us to be in a accessible CWD
  cd "${HOME}" || {
    printf -- '[%s] Unable to cd to user HOME for %s usage\n' "${_PROG_NAME}" "${_cmd}"
    return 1
  }

  # Eat argument
  _action="$1"
  shift

  case "${_action}" in
  ps | logs | images | inspect | stats)
    exec "${_cmd}" "${_action}" "$@"
    ;;
  checkup)
    if [ "${_cmd}" != "podman" ]; then
      printf -- '[%s] The "checkup" option is only supported with podman\n' "${_PROG_NAME}"
      return 1
    fi

    exec "${_cmd}" auto-update --dry-run "$@"
    ;;
  exec)
    _container="$1"
    shift

    exec "${_cmd}" exec -i -t "${_container}" "$@"
    ;;
  pid)
    exec "${_cmd}" inspect "$1" -f '{{ .State.Pid }}'
    ;;
  prune)
    exec "${_cmd}" system prune -a "$@"
    ;;
  pull)
    _dotfiles pull "$@"
    ;;
  disable)
    _prep_container || return 1
    _collect_containers "$@" || return 1

    if [ -z "${__containers}" ]; then
      printf -- '[%s] Must call %s with at least one container name\n' "${_PROG_NAME}" "${_action}"
      return 1
    fi

    # Run as the user
    # shellcheck disable=SC2086
    exec systemctl --user "${_action}" --now ${__args} ${__containers}
    ;;
  restart | status | stop)
    _prep_container || return 1

    # If we are just asking for "status" or "status --failed", allow it
    if [ "${_action}" = "status" ]; then
      if [ "$#" -le 0 ]; then
        # Run as the user
        # shellcheck disable=SC2086
        exec systemctl --user status
      else
        case "$1" in
        --failed)
          exec systemctl --user status --failed
          ;;
        *) ;;
        esac
      fi
    fi

    # Otherwise we expect at least one container name
    _collect_containers "$@" || return 1
    if [ -z "${__containers}" ]; then
      printf -- '[%s] Must call %s with at least one container name\n' "${_PROG_NAME}" "${_action}"
      return 1
    fi

    # If this is the NOT the "stop" action, make sure the container exists first
    if [ "${_action}" = "stop" ]; then
      # Run as the user
      # shellcheck disable=SC2086
      exec systemctl --user "${_action}" ${__args} ${__containers}
    else
      _valid_containers=""
      for _cont in ${__containers}; do
        # Run as the user
        # shellcheck disable=SC2086
        if systemctl --user status ${_cont} >/dev/null 2>&1; then
          if [ -z "${_valid_containers}" ]; then
            _valid_containers="${_cont}"
          else
            _valid_containers="${_valid_containers} ${_cont}"
          fi
        fi
        unset _cont
      done
      unset _cont

      if [ -z "${_valid_containers}" ]; then
        printf -- '[%s] Must call %s with at least one VALID container name (invalid: %s)\n' "${_PROG_NAME}" "${_action}" "${__containers}"
        return 1
      fi

      # Run as the user
      # shellcheck disable=SC2086
      exec systemctl --user "${_action}" ${__args} ${_valid_containers}
    fi
    ;;
  reload)
    _prep_container || return 1

    # Run as the user
    # shellcheck disable=SC2086
    exec systemctl --user daemon-reload
    ;;
  teardown)
    exec /opt/pyamsoft/bin/container-teardown "$@"
    ;;
  *)
    printf -- '[%s] Invalid action: "%s"\n' "${_PROG_NAME}" "${_action}"
    _usage || return 1
    return 1
    ;;
  esac

  return 0
}

main "$@" || exit 1
exit 0
