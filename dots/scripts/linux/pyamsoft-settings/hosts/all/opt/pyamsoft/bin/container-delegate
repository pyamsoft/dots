#!/bin/sh

_PROG_NAME="$(basename "$0")"
readonly _PROG_NAME

##
# Logs a message with newline, formatting, and a name tag
_log() {
  _msg="$1"
  shift

  printf -- "[%s]: ${_msg}\n" "${_PROG_NAME}" "$@" || return 1

  unset _msg
  return 0
}

##
# Log a message to stderr
_elog() {
  _log "$@" 1>&2 || return 1
  return 0
}

__scripts=""
__containers=""
__args=""

# Use podman, don't use docker
if command -v podman >/dev/null; then
  _cmd="podman"
elif command -v docker >/dev/null; then
  _cmd="docker"
else
  _elog 'Requires either "podman" or "docker" ("podman" preferred)'
  exit 1
fi
readonly _cmd

_dotfiles() {
  exec git --git-dir "${HOME}"/.dotfiles --work-tree "${HOME}" "$@"
}

_usage() {
  _log -- '%s' "$(
    cat <<EOF

($(id -un)) ${_PROG_NAME} <action>

<actions>

[container]:   Exectue ${_cmd} operations on containers

  images       Runs '${_cmd} images', passing all arguments
  inspect      Runs '${_cmd} inspect', passing all arguments
  logs         Runs '${_cmd} logs', passing all arguments
  networks     Runs '${_cmd} network ls', passing all arguments
  pid          Returns the PID of the containerized process on the host system
  ps           Runs '${_cmd} ps', passing all arguments
  stats        Runs '${_cmd} stats', passing all arguments

[service]:     Service management related operations

  reload       Runs 'systemctl --user daemon-reload'
  disable      Runs 'systemctl --user disable --now container@<name>'
  restart      Runs 'systemctl --user restart container@<name>'
  status       Runs 'systemctl --user status container@<name>'
  stop         Runs 'systemctl --user stop container@<name>'

[system]:      System management related operations

  checkup      Runs 'podman auto-update --dry-run' ("podman" ONLY)
  exec         Runs '${_cmd} exec -it <name>'
  prune        Runs '${_cmd} system prune -a'
  pull         Runs 'dotfiles pull'
  teardown     Runs 'container-teardown <name>'

EOF
  )"
}

_prep_container() {
  # Since the containers user lingers, we assume the XDG_RUNTIME_DIR exists, but it's not set in this sudo shell
  # So we manually set it and then call systemctl
  XDG_RUNTIME_DIR="/run/user/$(id -u)"
  export XDG_RUNTIME_DIR

  return 0
}

_collect_containers() {
  for _c in "$@"; do
    if [ -z "${__containers}" ]; then
      case "$1" in
      -*)
        if [ -z "${__args}" ]; then
          __args="$1"
        else
          __args="${__args} $1"
        fi
        ;;
      *)
        if [ -z "${__containers}" ]; then
          __scripts="$1"
          __containers="container@$1"
        else
          __scripts="${__scripts} $1"
          __containers="${__containers} container@$1"
        fi
        ;;
      esac
    else
      case "$1" in
      -*)
        if [ -z "${__args}" ]; then
          __args="$1"
        else
          __args="${__args} $1"
        fi
        ;;
      *)
        # In order
        if [ -z "${__containers}" ]; then
          __scripts="$1"
          __containers="container@$1"
        else
          __scripts="${__scripts} $1"
          __containers="${__containers} container@$1"
        fi
        ;;
      esac
    fi
    unset _c

    shift
  done
  unset _c

  return 0
}

main() {
  if [ -z "$1" ]; then
    _usage || return 1
    return 1
  fi

  # Podman expects us to be in a accessible CWD
  cd "${HOME}" || {
    _elog 'Unable to cd to user HOME for %s usage' "${_cmd}"
    return 1
  }

  # Eat argument
  _action="$1"
  shift

  case "${_action}" in
  ps | logs | images | inspect | stats)
    exec "${_cmd}" "${_action}" "$@"
    ;;
  checkup)
    if [ "${_cmd}" != "podman" ]; then
      _elog 'The "checkup" option is only supported with podman'
      return 1
    fi

    exec "${_cmd}" auto-update --dry-run "$@"
    ;;
  exec)
    _container="$1"
    shift

    exec "${_cmd}" exec -i -t "${_container}" "$@"
    ;;
  pid)
    _container="$1"
    shift

    exec "${_cmd}" inspect "${_container}" -f '{{ .State.Pid }}' "$@"
    ;;
  networks)
    exec "${_cmd}" network ls "$@"
    ;;
  prune)
    exec "${_cmd}" system prune -a "$@"
    ;;
  pull)
    _dotfiles pull "$@"
    ;;
  disable)
    _prep_container || return 1
    _collect_containers "$@" || return 1

    if [ -z "${__containers}" ]; then
      _elog 'Must call %s with at least one container name' "${_action}"
      return 1
    fi

    # Run as the user
    # shellcheck disable=SC2086
    exec systemctl --user "${_action}" --now ${__args} ${__containers}
    ;;
  restart | status | stop)
    _prep_container || return 1

    # If we are just asking for "status" or "status --failed", allow it
    if [ "${_action}" = "status" ]; then
      if [ "$#" -le 0 ]; then
        # Run as the user
        # shellcheck disable=SC2086
        exec systemctl --user status
      else
        case "$1" in
        --failed)
          exec systemctl --user status --failed
          ;;
        *) ;;
        esac
      fi
    fi

    # Otherwise we expect at least one container name
    _collect_containers "$@" || return 1
    if [ -z "${__containers}" ]; then
      _elog 'Must call %s with at least one container name' "${_action}"
      return 1
    fi

    # NOTE: (Peter) If the name passed here as a container does NOT actually exist, the script will
    #              just attempt to restart over and over again, which is bad mkay
    #
    # Run as the user
    # shellcheck disable=SC2086
    exec systemctl --user "${_action}" ${__args} ${__containers}
    ;;
  reload)
    _prep_container || return 1

    # Run as the user
    # shellcheck disable=SC2086
    exec systemctl --user daemon-reload
    ;;
  teardown)
    exec /opt/pyamsoft/bin/container-teardown "$@"
    ;;
  *)
    _elog 'Invalid action: "%s"' "${_action}"
    _usage || return 1
    return 1
    ;;
  esac

  return 0
}

main "$@" || exit 1
exit 0
